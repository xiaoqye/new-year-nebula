<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stubborn Nebula - Refined Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let user = null;

        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };

        onAuthStateChanged(auth, (u) => {
            user = u;
            if (user) { loadProgress(); }
        });

        initAuth();

        window.saveProgress = async (index) => {
            if (!user) return;
            const userDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'settings', 'progress');
            try {
                await setDoc(userDoc, { currentStateIndex: index }, { merge: true });
            } catch (e) { console.error(e); }
        };

        const loadProgress = async () => {
            if (!user) return;
            const userDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'settings', 'progress');
            const docSnap = await getDoc(userDoc);
            if (docSnap.exists()) {
                const data = docSnap.data();
                if (data.currentStateIndex !== undefined) {
                    window.jumpToState(data.currentStateIndex);
                }
            }
        };
    </script>
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Gloria Hallelujah', cursive; color: #ff8dfb; }
        #video-input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.25; z-index: 1; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #overlay { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; text-shadow: 0 0 10px #ff8dfb; }
        #controls { position: absolute; bottom: 30px; right: 30px; z-index: 20; }
        button { background: rgba(255,141,251,0.05); border: 1px solid #ff8dfb; color: #ff8dfb; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-family: inherit; transition: all 0.3s; font-size: 14px; }
        button:hover { background: #ff8dfb; color: #000; }
        #loading { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        .hint { font-size: 14px; margin-top: 15px; opacity: 0.6; }
    </style>
</head>
<body>

<div id="loading">
    <div>ðŸŽ€ Melting New Year Magic ðŸŽ€</div>
    <div class="hint">Click to start Camera & Sounds</div>
</div>

<div id="overlay">
    <div id="status">Ready...</div>
</div>

<video id="video-input" autoplay playsinline></video>
<div id="controls"><button onclick="restartExperience()">Reset âœ¨</button></div>
<div id="canvas-container"></div>

<script>
// --- AUDIO SYSTEM ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx, sfxGain;

function initAudio() {
    if (audioCtx) return;
    audioCtx = new AudioCtx();
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.12; 
    sfxGain.connect(audioCtx.destination);
}

function playSFX(type) {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    if (type === 'step') {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(660, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        g.gain.setValueAtTime(0.08, now); 
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.connect(g);
        g.connect(sfxGain);
        osc.start(now);
        osc.stop(now + 0.2);
    } else {
        // Celebration Chime only (Voice removed as requested)
        [0, 7, 12].forEach((interval, i) => {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.frequency.value = 330 * Math.pow(2, interval/12);
            g.gain.setValueAtTime(0, now + (i * 0.1));
            g.gain.linearRampToValueAtTime(0.06, now + (i * 0.1) + 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, now + 2);
            osc.connect(g);
            g.connect(sfxGain);
            osc.start(now + (i * 0.1));
            osc.stop(now + 2);
        });
    }
}

// --- THREE JS SYSTEM ---
const PARTICLE_COUNT = 90000;
const STATES = ['READY', 'FIVE', 'FOUR', 'THREE', 'TWO', 'ONE', 'HAPPY\nNEW YEAR\n2026'];
const COLORS = {
    PINK: new THREE.Color(0xff8dfb),
    CYAN: new THREE.Color(0x00f2ff),
    VIOLET: new THREE.Color(0x8a2be2),
    HEART: new THREE.Color(0xff2d55)
};

let currentStateIndex = 0;
let scene, camera, renderer, particles, geometry;
let particleData = [];
let handPoint = new THREE.Vector3(100, 100, 100);
let isHeartActive = false;
let heartSticky = false; 

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 18;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const x = (Math.random() - 0.5) * 60;
        const y = (Math.random() - 0.5) * 60;
        positions.set([x, y, 0], i * 3);
        particleData.push({
            current: new THREE.Vector3(x, y, 0),
            target: new THREE.Vector3(x, y, 0),
            velocity: new THREE.Vector3(),
            meltPhase: Math.random() * Math.PI * 2,
            isActive: false,
            driftSpeed: 0.01 + Math.random() * 0.02
        });
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending,
        opacity: 0.7
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

function updateTargets(text, showHeart = false) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1024; canvas.height = 1024;
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 1024, 1024);
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const lines = text.split('\n');
    let fontSize = lines.length > 1 ? 110 : 200;
    ctx.font = `900 ${fontSize}px "Gloria Hallelujah"`;
    lines.forEach((line, i) => ctx.fillText(line, 512, 512 + (i - (lines.length-1)/2) * (fontSize + 30)));

    if (showHeart) {
        ctx.lineWidth = 15;
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        for (let t = 0; t <= Math.PI * 2; t += 0.02) {
            const x = 512 + 22 * 16 * Math.pow(Math.sin(t), 3);
            const y = 480 - 22 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    const data = ctx.getImageData(0,0,1024,1024).data;
    const points = [];
    for(let y=0; y<1024; y+=2.6) {
        for(let x=0; x<1024; x+=2.6) {
            if(data[(Math.floor(y)*1024 + Math.floor(x))*4] > 128) {
                points.push(new THREE.Vector3((x-512)*0.038, -(y-512)*0.038, 0));
            }
        }
    }

    const colorAttr = geometry.attributes.color;
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const p = particleData[i];
        if (i < points.length) {
            p.target.copy(points[i]);
            p.isActive = true;
            const dist = points[i].length();
            if (showHeart && dist > 11) {
                colorAttr.setXYZ(i, COLORS.HEART.r, COLORS.HEART.g, COLORS.HEART.b);
            } else {
                const mix = (points[i].x + 15) / 30;
                const c = COLORS.PINK.clone().lerp(COLORS.CYAN, mix);
                colorAttr.setXYZ(i, c.r, c.g, c.b);
            }
        } else {
            p.isActive = false;
            p.target.set((Math.random()-0.5)*85, (Math.random()-0.5)*85, (Math.random()-0.5)*45);
            const mix = Math.random();
            const c = COLORS.VIOLET.clone().lerp(COLORS.CYAN, mix).multiplyScalar(0.15);
            colorAttr.setXYZ(i, c.r, c.g, c.b);
        }
    }
    colorAttr.needsUpdate = true;
}

window.jumpToState = (index) => {
    currentStateIndex = index;
    updateTargets(STATES[currentStateIndex]);
    document.getElementById('status').innerText = currentStateIndex === 6 ? "Happy 2026!" : `Step ${currentStateIndex}...`;
    if (index === 6) playSFX('celebrate');
};

const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
hands.onResults(res => {
    if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
        const lm = res.multiHandLandmarks[0];
        handPoint.set((0.5 - lm[8].x) * 45, (0.5 - lm[8].y) * 35, 0);
        
        let fingers = 0;
        [8, 12, 16, 20].forEach(t => { if(lm[t].y < lm[t-2].y) fingers++; });
        if (Math.sqrt(Math.pow(lm[4].x - lm[17].x, 2) + Math.pow(lm[4].y - lm[17].y, 2)) > 0.15) fingers++;

        const target = [5, 4, 3, 2, 1, 0][currentStateIndex];
        const gap = Math.sqrt(Math.pow(lm[4].x-lm[8].x, 2) + Math.pow(lm[4].y-lm[8].y, 2));
        
        const isBigHeartGesture = fingers === 2 && gap > 0.12 && lm[8].y < 0.6;

        if (currentStateIndex < 6) {
            if (fingers === target) {
                currentStateIndex++;
                playSFX('step');
                updateTargets(STATES[currentStateIndex]);
                document.getElementById('status').innerText = `Step ${currentStateIndex}...`;
                if (window.saveProgress) window.saveProgress(currentStateIndex);
                if (currentStateIndex === 6) playSFX('celebrate');
            }
        } else if (currentStateIndex === 6) {
            if (isBigHeartGesture && !heartSticky) {
                heartSticky = true;
                isHeartActive = true;
                updateTargets(STATES[6], true);
            }
        }
    } else {
        handPoint.set(100, 100, 100);
    }
});

const cameraUtils = new Camera(document.getElementById('video-input'), {
    onFrame: async () => await hands.send({ image: document.getElementById('video-input') })
});

function animate() {
    requestAnimationFrame(animate);
    const pos = geometry.attributes.position;
    const time = performance.now() * 0.001;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const p = particleData[i];
        if (p.isActive) {
            const meltX = Math.sin(time + p.meltPhase) * 0.1;
            const meltY = Math.cos(time * 0.7 + p.meltPhase) * 0.15;
            const t = p.target.clone().add(new THREE.Vector3(meltX, meltY, 0));
            p.velocity.add(new THREE.Vector3().subVectors(t, p.current).multiplyScalar(0.08));
            p.velocity.multiplyScalar(0.8);
            p.current.add(p.velocity);
        } else {
            p.current.x += Math.sin(time * 0.2 + p.meltPhase) * p.driftSpeed;
            p.current.y += Math.cos(time * 0.2 + p.meltPhase) * p.driftSpeed;
            if (p.current.x > 40) p.current.x = -40;
            if (p.current.y > 40) p.current.y = -40;
        }
        const d = p.current.distanceTo(handPoint);
        if (d < 4.5) {
            const push = new THREE.Vector3().subVectors(p.current, handPoint).normalize().multiplyScalar((4.5-d)*0.4);
            p.current.add(push);
        }
        pos.setXYZ(i, p.current.x, p.current.y, p.current.z);
    }
    pos.needsUpdate = true;
    renderer.render(scene, camera);
}

function restartExperience() {
    currentStateIndex = 0;
    isHeartActive = false;
    heartSticky = false;
    updateTargets(STATES[0]);
    document.getElementById('status').innerText = "Ready...";
    if (window.saveProgress) window.saveProgress(0);
}

document.body.onclick = () => {
    initAudio();
    document.getElementById('loading').style.display = 'none';
};

window.onload = () => {
    initThree();
    updateTargets(STATES[0]);
    cameraUtils.start();
    animate();
};
</script>
</body>
</html>